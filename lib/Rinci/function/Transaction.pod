package Rinci::function::Transaction; # just to make PodWeaver happy

# VERSION

1;
# ABSTRACT: Transactional system based on functions

=head1 SPECIFICATION VERSION

 1.1


=head1 SPECIFICATION

This document describes a transactional system based on functions, where several
function calls participate in a single transaction. This transactional system
has the following properties:

=over 4

=item * Client/server architecture

See L<Riap::Transaction>. Client can start more than one active transactions on
the server. Each transaction-management request and the function calls are
requested separately (each one is a separate Riap request).

=item * Undo/redo

Committed transactions are still recorded in the database along with its undo
information. Client can request to undo/redo the transactions. Thus the system
is also an undo/redo system.

=item * Relies on the functions for reliability/ACID properties

Server or framework provides the transaction manager (TM), but each function
acts as the resource manager (RM). It is the responsibility of the functions to
maintain ACID properties while modifying resources. For best results, each
function should be written carefully and tested extensively, and utilizes a
real, robust RM (like an RDBMS to store data or a transactional filesystem layer
to read/modify files). In the absence of a real RM, some ACID properties like
isolation and consistency might be compromised. For example

=back

Function performs its action by dividing the action into a series of unit action
steps, then performing the steps sequentially. For example, creating a Unix user
might be comprised of these steps: adding a record to /etc/passwd, adding a
record to /etc/shadow, adding a record to /etc/group, adding a record to
/etc/gshadow, creating home directory, copying skeleton files. Before actually
performing each step, the function should record the undo step first in the
transaction manager. This way, undo/rollback/rollback recovery can be performed
when needed.


=head2 Legends

Transaction statuses: i (in-progress), a (aborted, pending rolling back), C
(committed), R (rolled back), e (prepared, currently not described/reserved for
two-phase commit), u (committed, undoing), d (committed, redoing), U (committed,
undone), X (inconsistent, ignored). tx = transaction.


=head2 Fault tolerance when performing execution (do)

Note: Over L<Riap>, each client request might be performed by different
instances of TM (since it might be handle by different daemon child process). TM
currently does not detect whether a tx with status i has crashed; that is why
each step (and its undo step) needs to be idempotent and checks initial
condition. TM only recovers tx's with status a by rolling them back.

=over 4

=item 1. Client begins tx, TM creates a tx entry in its database

Initial tx status is i. Crash right after this moment is okay, since there is
nothing to recover. After TM is started again, during recovery it can continue
only needs to mark tx status as a. No undo steps have been created. Then TM
marks tx status as R.

=item 2. Client requests calling function F1, TM creates entry in its database

Crash right after this moment is also handled like in previous case.

=item 3. Function wants to do an action step (S1), records undo step (S1') to TM

Crash right after this moment will cause a rollback (S1') to be performed by TM,
even though the function has not performed S1. In this case S1' needs to do
nothing. That is why it is important that function (actually, all its steps and
undo steps) be idempotent and checks for initial condition.

Failure in performing rollback (S1') will cause the transaction status to become
X (inconsistent) and ignored. The transaction will be deleted during cleanup.

=item 4. Function performs S1

Crash during this moment (when S1 is not completed) is also handled like in
previous case. S1' needs to revert the (partial) side effects of S1.

Crash right after this moment (after S1 is completed) is also handled like in
previous case; this time S1 is already performed, so S1' needs to revert its
side effects.

=item 5. Function wants to do another action step (S2), records S2' to TM

Crash right after this moment will cause TM to mark tx status as a, then perform
S2' followed by S1' during recovery. After that tx status is set as R.

=item 6. Function performs S2

Crash right after this moment is also handled like in previous case.

=item 7. Function exits

Crash right after this moment is also handled like in previous case.

=item 8. Another function might be called

=item 9. Client requests commit, TM marks tx status as C

Crash during this moment (when tx status C is not yet recorded in TM's database)
is handled like in previous case. When TM is started again, it sweeps all tx's
that have I/A statuses and rolls them back.

Crash right after this moment no longer rolls back tx since tx is already
committed.

=back


=head2 Fault tolerance when performing undo

All of these steps will be performed by the same TM, since there is only one
client Riap request. Thus TM will be able to detect crash in the middle of the
steps.

=over 4

=item 1. Client requests undo for tx2, TM marks the transaction

TM will check first whether tx2 belongs to the client, whether tx status is C,
whether client need to undo its other tx's (tx1 and possible other tx's too). If
everything is OK, TX mark tx entry to u and set last-undo-step to none (no steps
is done first).

For example tx to undo is tx1, its undo steps are S2' and S1'.

Crash after this moment (or each next moments before the last) will cause the
next instance of TM to try to redo this tx, by performing its redo steps (S1 and
then S2). Failure in the middle of redo by the functions will cause the tx
status to be set to X and ignored.

=item 2. Function is called, instructed to perform undo

=item 3. Function wants to performs S2', records redo step (S2'' == S2) to TM

=item 4. Function performs S2'

=item 5. Function wants to perform S1', records undo step (S1'' == S1) to TM

=item 6. Function performs S1'

=item 7. TM marks tx status to U

=back


=head2 Fault tolerance when performing redo

This case is handled similar to when performing redo, except TM will only redo
tx's with status C. At the beginning of redo TM will set tx status to d. And at
the end tx status will be set to C again.


=head2 Fault tolerance when performing rollback or recovery

During startup, TM will list all tx's with status A, u, d. It will then try to
roll back each of this tx, by performing its undo (or redo) steps so that tx
status is (respectively) R, C, U. These are all performed by the same TM
instance (since there is no client Riap request involved yet). Crash in the
middle of recovery can be repeated since tx status are still A/u/d. That is why
steps need to be idempotent because they might be called more than once.

Failure in the steps can cause TM to set transaction status to X (inconsistent,
ignored).


=head2 The order of steps and function calls in nested calls during undo/rollback

A nested call happens when a function (one of its steps, to be exact) calls
another function within the same transaction.

Without any nested call, ordering steps and function calls in undo/rollback is
simpler: we simply reverse the order of calls by time, and the order of steps in
each function by time. Example:

 time   function     step
 ----   --------     ----
  t1       F1        S1.1
  t2                 S1.2
  t3                 S1.3
  t4       F2        S2.1
  t5                 S2.2

The order of execution (do) is F1(S1.1, S1.2, S1.3) and then F2(S2.1, S2.2). To
undo/rollback, the order of execution is F2(S2.2, S2.1) followed by F1(S1.3,
S1.2, S1.1).

With nested call, a function that calls other functions in the middle will need
to be called twice during undo/rollback, since we try to trace back the order of
steps by time.

For example:

Another example that illustrates this more clearly. F1 calls F2 in its last
step, and F2 calls F3 in the middle of the steps. Finally F4 executes after F2
finishes.

 time      function    nest_level      step
 ----   -------------  ----------      ----
  t1       F1            1             S1.1
  t2                                   S1.2
  t2                                   S1.3 (this step calls F2)
  t3         F2            2           S2.1
  t4         |                         S2.2 (this step calls F3)
  t5         | F3            3         S3.1
  t6         |                         S3.2
  t7         F2                        S2.3
  t8                                   S2.4
  t9                                   S2.5
  t10      F4            1             S4.1
  t11                                  S4.2

The order of execution during undo/rollback will be:

 F4(S4.2, S4.1)
 F2(S2.5, S2.4, S2.3)
 F3(S3.2, S3.1)
 F2(S2.2, S2.1)
 F1(S1.2, S1.1)

Notice how F2 is called twice.


=head1 FAQ

=head2 Why is this useful?

The protocol is a pretty generic and simple way to build transactional system,
even on heterogenous, multiuser environment. If the functions are written
carefully, the system can be reliable. And even if some of the ACID properties
are compromised due to lack of real RM, the system is still useful for its
undo/redo capability.

=head2 What are the drawbacks?

The reliability of the system rests on the reliability of each involved
function. One buggy function can break the transaction.


=head1 SEE ALSO

L<Riap::Transaction>

L<Rinci>

L<Rinci::function::Undo>

