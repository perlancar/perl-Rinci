package Rinci::function; # just to make PodWeaver happy

# VERSION

1;
# ABSTRACT: Metadata for your functions/methods

=head1 SPECIFICATION VERSION

 1.1


=head1 INTRODUCTION

This document describes metadata for functions/methods. This specification is
part of L<Rinci>. Please do a read up on it first, if you have not already done
so.


=head1 SPECIFICATION

B<Result envelope>. Function should return an enveloped result to express error
code/message as well as actual result. The envelope can be produced by the
function itself, or added by a wrapper tool. Result envelope is modeled after
HTTP or L<PSGI> response, it is an array in the following format:

 [STATUS, MESSAGE, RESULT, META]

STATUS is a 3-digit integer, much like HTTP response status code and is
explained further in L</"Envelope status codes">. MESSAGE is a string containing
error message. RESULT (or PAYLOAD) is the actual content to be returned and can
be omitted or set to undef if the function does not need to return anything.
META is called result metadata, a hash containing extra data, analogous to HTTP
response headers. Result metadata is specified further in L<Rinci::result>.

Some example of an enveloped results:

 [200, "OK", 42]
 [404, "Not found"]
 [500, "Can't delete foo: permission denied", {errno=>51}]
 [200, "Account created", {id=>9323}, {undo_data=>["delete_account"]}]

As mentioned, an enveloped result can contain error code/message as well as the
actual result. It can also be easily converted to HTTP response message. And it
can also contain extra data, useful for things like the undo protocol (explained
in L<Rinci::function::Undo>).

B<Special arguments>. Special arguments are some known arguments that start with
dash (C<->) and serve special purposes. You need not specify them in the C<args>
metadata property. Examples of special arguments include C<-undo_action>,
C<-undo_data>, C<-dry_run>, and they will be explained in relevant sections
below.

B<Functions vs methods>. Since in many programming languages (like Perl 5,
Python, Ruby, PHP) static functions are not that differentiated from methods,
functions and methods share the same Rinci spec. But there are certain
properties that can be used to declare if a function is (also) a method or not.
See C<is_func>, C<is_meth>, C<is_class_meth> properties below for details.

B<Multiple dispatch>. This specification also does not (yet) have any
recommendation on how to best handle functions in languages that support
multiple dispatch, like Perl 6: whether we should create multiple metadata or
just one. It is more up to the tool and what you want to do with the metadata.


=head2 Envelope status codes

In general, status codes map directly to HTTP response status codes. Below are
the suggestion on which codes to use (or avoid).

=over 4

=item * 1xx code

Currently not used.

=item * 2xx code

200 should be used to mean success.

206 can be used to signal partial content, for example: a C<read_file()>
function which accepts C<byte_start> and C<byte_end> arguments should return 206
when only partial file content is returned. But in general, use 200 as some
callers will simply check for this exact code (instead of checking for range
200-299).

=item * 3xx code

301 (moved) can be used to redirect callers to alternate location, although this
is very rare.

304 (not modified, nothing done). Used for example by setup functions to
indicate that nothing is being modified or no modifying action has been
performed (see Setup::* modules in CPAN).

=item * 4xx code

400 (bad request, bad arguments) should be returned when the function encounters
invalid input. A function wrapper can return this code when the function
arguments fail the argument schema validation (specified in the C<args>
property).

401 (authentication required).

403 (forbidden, access denied, authorization failed).

404 (not found). Can be used for example by an object-retrieval functions (like
C<get_user()>) and the object is not found.

For object-listing functions (like C<list_users()>), when there are no users
found matching the requested criteria, 200 code should still be returned with an
empty result (like an empty array or hash).

Also in general, an object-deletion function (like C<delete_user()>) should also
return 200 (or perhaps 304, but 200 is preferred) instead of 404 when the object
specified to be deleted is not found, since the goal of the delete function is
reached anyway.

408 (request timeout).

409 (conflict). Can be used for example by a C<create_user()> function when
receiving an already existing username.

412 (precondition failed). Similar to 409, but can be used to indicate lack of
resources, like disk space or bandwidth. For lacking authentication and
authorization, use 401 and 403 respectively.

480 (transaction error, e.g. transaction status is aborted so further requests
for this transaction is ignored until transaction is aborted.)

484 (no such transaction).

=item * 5xx code

500 is the general code to use when a failure occurs during the execution of a
function. for example when a C<delete_file()> function fails to delete specified
file (though in this case it can also choose to return 403 instead, which is
more specific).

501 (not implemented)

503 (service unavailable). You can use this when service is temporarily
unavailable, e.g. when system load is too high, a required service is down, etc.
Users should try again at a later time.

507 (insufficient storage)

521 (maximum retries reach)

531 (bad metadata) is used when there is something wrong with the metadata.

532 (failure in recording transaction) when there is a failure in updating
transaction status or in preparing/committing/rolling back the transaction.

Try not to use code greater than 555, as some tools use (CODE-300) for error
codes that must fit in one unsigned byte (like L<Perinci::CmdLine>).

=back


=head2 Property: is_func => BOOL

Specify that the function can be called as a static function (i.e. procedural,
not as a method). Default is true if unspecified, but becomes false if is_meth
or is_class_meth is set to true.

Example:

 # specify that function can be called a method *as well as* a static function
 is_meth => 1,
 is_func => 1, # if not specified, will default to false after is_meth set to 1


=head2 Property: is_meth => BOOL

Specify that the function can be called as an instance (object) method. Default
is false.

Example:

 # specify that function is a method
 is_meth => 1,


=head2 Property: is_class_meth => BOOL

Specify that the function can be called as a class method. Examples of class
methods include the constructor, but there are others. Default is false.

Example:

 # specify that function is a class method
 is_class_meth => 1,


=head2 Property: args => HASH

Specify arguments. Property value is hash of argument names and argument
specification. Argument name must only contain letters, numbers, and underscores
(and do not start with a number).

Argument specification is a hash containing these keys:

=over 4

=item * B<schema> => SCHEMA

L<Data::Sah> schema for argument value.

=item * B<summary> => STR

A one-line plaintext summary, much like the C<summary> property in variable
metadata.

=item * B<req> => BOOL

Specify that argument is required (although its value can be undef/null).
Default is false.

=item * B<description> => STR

A longer description of marked up text, much like the C<description> property.
It is suggested to format the text to 74 columns.

=item * B<tags> => ARRAY OF (STR|HASH)

An array of tags, can be used by tools to categorize arguments. Not unlike the
C<tags> property.

=item * B<pos> => INT

Argument position when specified in an ordered fashion, e.g. in an array. Starts
from zero.

=item * B<greedy> => BOOL

Only relevant if B<pos> is specified, specify whether argument should gobble up
all remaining values in an ordered argument list into an array.

=item * B<cmdline_aliases> => HASH

Specify aliases for use in command-line options (or other possibly suitable
situation where arguments are parsed from command-line-like options). Keys are
alias names, values are itself hashes (alias specification). Valid alias
specification keys: C<summary> (a string, optional), C<schema> (optional,
defaults to argument's schema), C<code> (a code to set argument value, optional,
will be given reference to arguments hash; if not set, the default behavior is
simply to set the argument value).

=item * B<completion> => CODE

A code to supply argument value completion. Will be explained in the examples.

=back

Example function metadata and its implementation in Perl:

 $SPEC{multiply2} = {
     v => 1.1,
     summary => 'Multiple two numbers',
     args => {
         a => {
             summary => 'The first operand',
             description => '... a longer description ...',
             schema=>'float*',
             pos => 0,
             tags => ['category:operand'],
         },
         b => {
             summary => 'The second operand',
             description => '... a longer description ...',
             schema => 'float*',
             pos => 1,
             tags => ['category:operand'],
         },
         round => {
             summary => 'Whether to round result',
             description => '... a longer description ...',
             schema => [bool => {default=>0}],
             pos => 2,
             tags => ['category:options'],
             cmdline_aliases => {
                 r=>{},
                 R=>{summary=>'Equivalent to --round=0',
                     code=>sub {$_[0]{round}=0}},
             },
         },
     }
 };
 sub multiply2 {
     my %args = @_;
     my $res = $args{a} * $args{b};
     $res = int($res) if $round;
     [200, "OK", $res];
 }

By default, without any wrapper, the function is called with a named hash style:

 multiply2(a=>4, b=>3);  # 12

But with the information from the metadata, a wrapper tool like
Sub::Spec::Wrapper is able to change the calling style to positional:

 multiply2(4, 3.1, 1);  # 12

A command-line tool will also enable the function to be called named options as
well as positional arguments:

 % multiply2 --a 2 --b 3
 % multiply2 2 --b 3
 % multiply2 2 3

As mentioned earlier, C<cmdline_alises> is parsed by command-line option parser:

 % multiply2 2 3.5 -r ; # equivalent to multiply2 2 3 --round
 % multiply2 2 3.5 -R ; # equivalent to multiply2 2 3 --noround (--round=0)

Aliases in C<cmdline_aliases> are not recognized as real arguments:

 multiply2(a=>4, b=>3, r=>0);  # unknown argument r

Another example (demonstrates C<cmdline_aliases>):

 $SPEC{smtpd} = {
     v => 1.1,
     summary => 'Control SMTP daemon',
     args    => {
         action => {
             schema => ['str*' => {in=>[qw/status start stop restart/]}],
             pos    => 0,
             req    => 1,
             cmdline_aliases => {
                 status => {
                     schema    => [bool=>{is=>1}],
                     summary   => 'Alias for setting action=status',
                     code      => sub { $_[0]{action} = 'status' },
                 },
                 start => {
                     schema    => [bool=>{is=>1}],
                     summary   => 'Alias for setting action=start',
                     code      => sub { $_[0]{action} = 'start' },
                 },
                 stop => {
                     schema    => [bool=>{is=>1}],
                     summary   => 'Alias for setting action=stop',
                     code      => sub { $_[0]{action} = 'stop' },
                 },
                 restart => {
                     schema    => [bool=>{is=>1}],
                     summary   => 'Alias for setting action=restart',
                     code      => sub { $_[0]{action} = 'restart' },
                 },
             },
         },
         force => {
             schema => 'bool',
         },
     },
 };

Another example (demonstrates B<greedy>):

 $SPEC{multiply_many} = {
     v => 1.1,
     summary => 'Multiple numbers',
     args    => {
         nums   => {
             schema => ['array*' => {of=>'num*', min_len=>1}],
             pos    => 0,
             greedy => 1
         },
     },
 };
 sub multiply_many {
     my %args = @_;
     my $nums = $args{nums};

     my $ans = 1;
     $ans *= $_ for @$nums;
     [200, "OK", $ans];
 }

After wrapping, in positional mode it can then be called:

 multiply_many(2, 3, 4);  # 24

which is the same as (in normal named-argument style):

 multiply_many(nums => [2, 3, 4]);  # 24

In command-line:

 % multiply-many 2 3 4

in addition to the normal:

 % multiply-many --nums '[2, 3, 4]'

B<completion>. This argument specification key specifies how to complete
argument value (e.g. in shell or L<Riap::HTTP>) and is supplied an anonymous
function as value. The function will be called with arguments: word=>... (which
is the formed word so far), args=>... (which is the C<args> property value). The
function should return an array containing a list of possible candidates. For an
example of implementation for this, see L<Perinci::BashComplete> in Perl which
provides tab completion for argument values. Example:

 $SPEC{delete_user} = {
     v => 1.1,
     args => {
         username => {
             schema     => 'str*',
             pos        => 0,
             completion => sub {
                 my %args = @_;
                 my $word = $args{word} // "";

                 # find users beginning with $word
                 local $CWD = "/home";
                 return [grep {-d && $_ ~~ /^\Q$word/} <*>];
             },
         },
         force => {schema=>[bool => {default=>0}]},
     },
 };

When C<delete_user> is executed over the command line and the Tab key is
pressed:

 $ delete-user --force --username fo<tab>
 $ delete-user fo<tab>

then B<bash> will try to complete with usernames starting with C<fo>.


=head2 Property: args_as => STR

Specify in what form the function expects the arguments. The value is actually
implementation-specific since it describes the function implementation. For
example in L<Perinci> for Perl, these values are recognized: C<array>, C<hash>,
C<arrayref>, C<hashref>. This property is useful for wrapper to be able to
convert one form to another.

The default value is also left to the implementation.

For interimplementation communication (e.g. via L<Riap::HTTP> or L<Riap::TCP>),
named arguments are always used so this property is irrelevant.

=head2 Property: result => HASH

Specify function return value. It is a hash containing keys:

=over 4

=item * B<schema>

A Sah schema to validate the result

=item * B<summary>

Like the C<summary> property in variable metadata.

=item * B<description>

Like the C<description> property. Suggested to be formatted to 78 columns.

=back

Note that since functions normally return enveloped result, instead of
returning:

 RESULT

your functions normally have to return an enveloped result:

 [STATUS, MESSAGE, RESULT, METADATA]

Examples:

 # result is an integer
 result => {schema => 'int*'}

 # result is an integer starting from zero
 result => {schema => ['int*' => {ge=>0}]}

 # result is an array of records
 result => {
     summary => 'Matching addressbook entries',
     schema => ['array*' => {
         summary => 'blah blah blah ...',
         of      => ['hash*' => {allowed_keys=>[qw/name age address/]} ]
     }]
 }


=head2 Property: result_naked => BOOL

If set to true, specify that function does not envelope its results. The default
is false, to encourage functions to create envelopes. However, wrapper should be
able to create or strip envelope if needed. For example, if you have
"traditional" functions which does not do envelopes, you can set this property
to true, and the wrapper can generate the envelope for the functions.


=head2 Property: examples => ARRAY

This property allowed you to put examples in a detailed and structured way, as
an alternative to putting everything in C<description>.

Each example shows what arguments are used, what the results are, and some
description. It can be used when generating API/usage documentation, as well as
for testing data. It is expressed a hash containing these keys:

=over 4

=item * args => HASH

Arguments used to produce result.

=item * argv => ARRAY

An alternative to C<args>, for example when function is run from the command
line.

=item * status => INT

Status from envelope. If unspecified, assumed to be 200.

=item * result => DATA

Result data.

=item * summary => STR

A one-line summary of the example, much like C<summary> property. You should
describe, in one phrase or sentence, what the example tries to demonstrate. You
can skip the summary if the example is pretty basic or things are already clear
from the C<args> alone.

=item * description => STR.

Longer marked up text about the example (e.g. discussion or things to note),
suggested to be formatted to 72 columns.

=back

Example:

 # part of metadata for Math::is_prime function
 examples => [
     {
         args => {num=>10},
         result => 0,
         # summary no needed here, already clear.
     },
     {
         argv => [-5],
         result => 1,
         summary => 'Also works for negative integers',
     },
     {
         args => {},
         result => 400,
         summary => 'Num argument is required',
     },
 ],


=head2 Property: features => HASH

The C<features> property allows functions to express their features. Each hash
key contains feature name, which must only contain letters/numbers/underscores.

Below is the list of defined features. New feature names may be defined by
extension.

=over 4

=item * feature: reverse => BOOL

Default is false. If set to true, specifies that function supports reverse
operation. To reverse, caller can add special argument C<-reverse>. For example:

 $SPEC{triple} = {
     v => 1.1,
     args     => {num=>{schema=>'num*'}},
     features => {reverse=>1}
 };
 sub triple {
     my %args = @_;
     my $num  = $args{num};
     [200, "OK", $args{-reverse} ? $num/3 : $num*3];
 }

 triple(num=>12);              # => 36
 triple(num=>12, -reverse=>1); # =>  4

NOTE: Abilitity to express conditional reversibility is considered.

=item * feature: undo => BOOL

Default is false. If set to true, specifies that function supports undo
operation using the undo protocol specified in L<Rinci::function::Undo>. Undo is
similar to C<reverse> but needs some state to be saved and restored for do/undo
operation, while reverse can work solely from the arguments.

L<Riap::Transaction> requires functions participating in a transaction be
declared with this feature.

=item * feature: tx => HASH

Specify transactional features. Can be set to a hash containing these keys:
B<use> (bool, defaults to false, whether function can use transaction if it
exists), B<req> (bool, defaults to false, whether function always require
running in a transaction, B<start> (bool, defaults to false, whether function
starts a new transaction on invocation), B<end> (bool, defaults to false,
whether function ends [commits/rolls back] transaction).

See L<Rinci::function::Transaction> for more details on transactions. Currently
there is little further specification; transactional feature is used alongside
with undo protocol, described in L<Rinci::function::Undo>.

L<Riap::Transaction> requires functions participating in a transaction be
declared with this feature, because the specification is for allowing
transactional operations as well as undo/redo of committed transactions.

=item * feature: dry_run => BOOL

Default is false. If set to true, specifies that function supports dry-run
(simulation) mode. Example:

 use Log::Any '$log';

 $SPEC{rmre} = {
     summary  => 'Delete files in curdir matching a regex',
     args     => {re=>{schema=>'str*'}},
     features => {dry_run=>1}
 };
 sub rmre {
     my %args    = @_;
     my $re      = qr/$args{re}/;
     my $dry_run = $args{-dry_run};

     opendir my($dir), ".";
     while (my $f = readdir($dir)) {
         next unless $f =~ $re;
         $log->info("Deleting $f ...");
         next if $dry_run;
         unlink $f;
     }
     [200, "OK"];
 }

The above Perl function delete files, but if passed argument C<-dry_run> => 1
(simulation mode), will not actually delete files, only display what files match
the criteria and would have be deleted.

Specifying a function as supporting dry_run means, among others:

=over 4

=item * If dry_run is requested, function will have no side effects

It will behave like a pure function, and thus have the properties of a pure
function.

=back

=item * feature: pure => BOOL

Default is false. If set to true, specifies that function is "pure" and has no
"side effects" (these are terms from functional programming / computer science).
Having a side effect means changing something, somewhere (e.g. setting the value
of a global variable, modifies its arguments, writing some data to disk,
changing system date/time, etc.) Specifying a function as pure means, among
others:

=over 4

=item * the function needs not be involved in undo operation;

=item * you can safely include it during dry run;

=back

=item * feature: immutable => BOOL

Default is false. If set to true, specifies that function always returns the
same result when given the same argument values. This enables optimization like
memoization. An example of an immutable function is C<sub { $_[0]+$_[1] }> where
its results only depend on the arguments. Example of a mutable function would be
C<rand()> or C<read()> that reads contents from a file.

=item feature: idempotent => BOOL

Default is false. If set to true, specifies that function is idempotent.
Idempotency means that repeated invocation of a function (each with the same
arguments) will have the same effect as a single invocation. In other words,
extra invocation will not have any effect.

L<Riap::Transaction> requires functions (to be more exact, their undo steps)
participating in a transaction be idempotent, because in some cases they might
be called more than once, e.g. if transaction manager crashes in the middle of
rollback or rollback recovery and the process needs to be repeated.

Some operations, like reading a database row or a file's content, is inherently
idempotent (or to be exact nullipotent). Another example is setting or updating
an entity to some specific value, or deleting some entity. Repeated invocation
of the operation will still sets the entity to the same value, or still deletes
the entity.

Some other operations are inherently non-idempotent, for example sending an
email. Repeated invocation will cause multiple emails to be sent, and once sent
to an external server, it's usually hard to undo.

Yet some other operations are non-idempotent, but can be made idempotent simply
by checking whether the target object(s) has (have) reached the final desired
state, (optionally additionally also checking whether they are in the correct
original state to begin with). For example, a function that renames a file can
record the original file that was renamed (its MD5 checksum, size, or what not)
and refuse to rename again if the file to be renamed is not the original file.

=back


=head2 Property: deps => HASH

This property specifies function's dependencies to various things. It is a hash
of dep types and values. Some dep types are special: C<all>, C<any>, and
C<none>.

 deps => {
     DEPTYPE => DEPVALUE,
     ...,
     all => [
         {DEPTYPE=>DEPVALUE, ...},
         ...,
     },
     any => [
         {DEPTYPE => DEPVALUE, ...},
         ...,
     ],
     none => [
         {DEPTYPE => DEPVALUE, ...},
         ....,
     ],
 }

A dependency can be of any type: another function, environment variables,
programs, OS software packages, etc. It is up to the dependency checker library
to make use of this information.

For the dependencies to be declared as satisfied, all of the clauses must be
satisfied.

Below is the list of defined dependency types. New dependency type may be
defined by an extension.

=over 4

=item * dep: env => STR

Require that an environment variable exists and is true, where true is in the
Perl sense (not an empty string or "0"; " " and "0.0" are both true). Example:

 env => 'HTTPS'

=item * dep: prog => STR

Require that a program exists. If STR doesn't contain path separator character
'/' it will be searched in PATH. Windows filesystem should also use Unix-style
path, e.g. "C:/Program Files/Foo/Bar.exe".

 prog => 'rsync'   # any rsync found on PATH
 prog => '/bin/su' # won't accept any other su

=item * dep: code => CODE

Require that anonymous function returns a true value after called, where the
notion of true depends on the host language. Example in Perl:

 code => sub {$>}  # i am not being run as root

Example in Ruby:

 "code" => Proc.new { Process.euid > 0 }  # i am not being run as root

=item * dep: undo_storage => STORAGE_SPEC

Specify that function requires some external undo storage. STORAGE_SPEC is a
hash. Currently the only known keys are: C<tmp_dir> with the value of 1,
C<trash_dir> with the value of 1 (trash_dir is basically the same as tmp_dir,
but provides clue to the undo/transaction manager that the directory is used for
trash, so it can arrange directory to be in the same partition, etc.)

Example:

 undo_storage => {trash_dir=>1}

=item * dep: all => [DEPHASH, ...]

A "meta" type that allows several dependencies to be joined together in a
logical-AND fashion. All dependency hashes must be satisfied. For example, to
declare a dependency to several programs and an environment variable:

 all => [
     {prog => 'rsync'},
     {prog => 'tar'},
     {env  => 'FORCE'},
 ],

=item * dep: any => [DEPHASH, ...]

Like C<all>, but specify a logical-OR relationship. Any one of the dependencies
will suffice. For example, to specify requirement to alternative Perl modules:

 or => [
     {perl_module => 'HTTP::Daemon'},
     {perl_module => 'HTTP::Daemon::SSL'},
 ],

=item * dep: none => [DEPHASH, ...]

Specify that none of the dependencies must be satisfied for this type to be
satisfied. Example, to specify that the function not run under SUDO or by root:

 none => [
     {env  => 'SUDO_USER'   },
     {code => sub {$> != 0} },
 ],

Note that the above is not equivalent to below:

 none => [
     {env => 'SUDO_USER', code => sub {$> != 0} },
 ],

which means that if none or only one of 'env'/'code' is satisfied, the whole
dependency becomes a success (since it is negated by 'none'). Probably not what
you want.

=back

If you add a new language-specific dependency type, please prefix it with the
language code, e.g. C<perl_module>, C<perl_func>, C<ruby_gem>, C<python_egg>.
These dependency types have also been defined by some existing tools: C<deb>
(dependency to a Debian package), C<rpm> (dependency to an RPM package),
C<js_url> (loading a remote JavaScript script URL), C<file> (existence of a),
C<perl_run_func> (running a Perl subroutine and getting a successful enveloped
result). Some of these might be declared as part of the core dependency types in
the future.


=head1 FAQ

=head2 What is the difference between C<summary> or C<description> in the Sah schema and arg specification?

Example:

 {
     args => {
         src => {
             summary => "Source path",
             description => "...",
             schema => ["str*", {
                 summary => "...",
                 description => "...",
                 ...
             }],
             ...
         },
         dest => {
             summary => "Target path",
             description => "...",
             schema => ["str*", {
                 summary => "...",
                 description => "...",
                 ...
             }],
             ...
         },
         ...
     },
 }

As you can see, each argument has a C<summary> and C<description>, but the
schema for each argument also has a C<summary> and C<description> schema
clauses. What is the difference and which should be put into which?

The argument specification's C<summary> (and C<description>) describe the
argument itself, in this example it says that C<src> means "The source path" and
C<dest> means "The target path". The argument schema's C<summary> (and
C<description>) describe the data type and valid values. In this example it
could say, e.g., "a Unix-path string with a maximum length of 255 characters".
In fact, C<src> and C<dest> are probably of the same type ("Unix path") and can
share schema.

 {
     ...
     args => {
         src => {
             ...
             schema => "unix_path",
         },
         dest => {
             ...
             schema => "unix_path",
         },
         ...
     },
 }

=head2 What is the difference between setting req=>1 in the argument specification and req=>1 in schema?

Example:

 # Note: remember that in Sah, str* is equivalent to [str => {req=>1}]
 args => {
     a => {         schema=>"str"  },
     b => {         schema=>"str*" },
     c => { req=>1, schema=>"str"  },
     d => { req=>1, schema=>"str*" },
 }

In particular look at C<b> and C<c>. C<b> is not a required argument (no req=>1
in the argument spec) but if it is specified, than it cannot be undef/null
(since the schema says [str=>{req=>1}], a.k.a "str*"). On the other hand, C<c>
is a required argument (req=>1 in the argument spec) but you can specify
undef/null as the value. The following are valid:

 func(c=>undef, d=>1);

But the following are not:

 func(b=>1, d=>1);  # c is not specified
 func(b=>undef, c=>1, d=>1);  # b has undef value
 func(b=>1, c=>1, d=>undef);  # d has undef value

=head2 Should I add a new metadata property, or add a new feature name to the C<features> property, or add a new dependency type to the C<deps> property?

If your property describes a dependency to something, it should definitely be a
new dependency type. If your property only describes what the function can do
and does not include any wrapper code, then it probably goes into C<features>.
Otherwise, it should probably become a new metadata property.

For example, if you want to declare that your function can only be run under a
certain moon phase (e.g. full moon), it should definitely go as a new dependency
type, so it becomes: deps => { moon_phase => 'full' }.

Another example, C<reverse> is a feature name, because it just states that if we
pass C<-reverse> => 1 special argument to a reversible function, it can do a
reverse operation. It doesn't include any wrapper code, all functionality is
realized by the function itself. On the other hand, C<timeout> is a metadata
property because it involves adding adding some wrapping code (a timeout
mechanism, e.g. an eval() block and alarm() in Perl).


=head1 SEE ALSO

L<Data::Sah>

L<Rinci>

L<Rinci::function::Transaction>

L<Rinci::function::Undo>

=cut
