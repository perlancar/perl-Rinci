package Rinci::Protocol::HTTP; # just to make PodWeaver happy

1;
# ABSTRACT: Actions on code entities over HTTP

=head1 SPECIFICATION VERSION

 1.1

=head1 ABSTRACT

This document specifies a protocol for performing actions on code entities over
HTTP, which include: requesting metadata, remote call on functions, etc. The
protocol can be used for REST/HTTP API service, RPC, remote code management,
etc.

The specification is called 'Rinci HTTP' for short.


=head1 RATIONALE

REST/HTTP API service is now popular, provided by many websites. However, there
is no uniform access: service is slightly different from website to website.
Even for calling a single simple function you will need to consult the API
documentation for each website. First of all, the URL scheme is slightly
different: some use C<http://api.example.org/FUNC?ARG=VAL>, other would prefer
C<http://example.org/api/v1/FUNC/VAL>, and there are many other varieties. Some
websites directly utilize HTTP methods (verbs) for action names, some avoid this
and only use GET/POST. Some accept JSON as input/output decoding format, others
only XML. There is no common way to select which format you want: some look in
the C<Accept> request header, others use a query parameter. And so on.

So the first goal of Rinci HTTP protocol is to let websites keep their own
preferred URL schemes, but provide a common way that is guaranteed to work
across all Rinci-compliant web API service. This is accomplished using special
HTTP request headers and query parameters (detailed later).

The second goal of Rinci HTTP is to provide more capabilities than just remote
calling (which is what an API service essentially is). It provides a way to
request metadata on functions (for self-documenting API service, since function
metadata contains documentation, among others). It also provides access and
metadata to other code entities, like variables, packages, and more. This can be
used for remote code management. (Actually, a set of API functions can be used
for providing those capabilities; the Rinci protocol just abstracts/standardizes
the capabilities.)

Rinci HTTP also defines some other features like passing logging messages from
the server, for debugging.

By using Rinci HTTP you can create a web service that has uniform access
mechanism. By opening access to metadata you allow for powerful and convenient
client tools to use your service, from self-documentation, remote tab
completion, logging/debugging messages, and more.


=head1 TERMINOLOGIES

=over 4

=item * Server

A server is an HTTP service (e.g. a web application or middleware running on top
of a webserver), listening for HTTP requests. Its responsibility is to accept
HTTP request, extract/parse Rinci request from the HTTP request, process the
Rinci request, and return an enveloped result inside the HTTP response.

=item * Client

A client can be any normal bare HTTP client (like the B<curl> or B<wget>
program), or some library which understands Rinci HTTP protocol and can provide
additional abstraction and convenience. For example, the L<Sub::Spec::Use> Perl
module can provide the illusion of "loading" remote modules and functions from a
Rinci HTTP server as if they were local. The L<apicli> command-line client
offers documentation, remote tab completion, and more.

=item * Rinci request

Rinci request is a hash containing at least these keys: B<uri> which is the URI
to code entity, and B<action> which is the action to perform on the code entity.
The specification requires a minimal set of actions that can be performed on a
compliant server.

=back


=head1 SS REQUEST

An SS request is a hashref containing some predefined keys, listed below. SS
server SHOULD return an HTTP 400 error code if client sends an unknown key. Not
all keys are required for each request.

=over 4

=item * command => STR

If not specified, default is 'call'. The list of all currently known commands is
written below. A server should implement some or all of the listed commands. At
the very least it MUST implement 'about' and 'call'. It SHOULD return HTTP 502
status if a command is unknown. It can implement new commands if deemed
necessary.

'about' command, to request information about the server and the request itself.
For this command, no other request key is necessary. The server MUST return a
hashref like this:

 {
  version        => [1, 0], # Sub::Spec::HTTP specification version
  input_formats  => [qw/json phps yaml/], # supported input formats
  output_formats => [qw/json pretty nopretty
                        yaml phps html/], # supported output formats
  # other extra keys are allowed, like ...
  server_url     => 'http://localhost:5000/api/',
  commands       => [...], # commands known by this server
 }

'call' command, to call a subroutine and return its result. For this command,
request C<uri> must be specified and contains at least module and subroutine
name.

'list_commands' command, to list known commands. No other request key is
necessary.

'list_mods' command, to list known modules. No other request key is necessary.

'list_subs' command, to list known subroutines in a module. Request key C<uri>
must be specified and contains at least module name.

'usage' command, to show subroutine's usage (like list of arguments and
description for each). Request key C<uri> is required and must contain at least
module and subroutine name.

'spec' command, to request spec for a subroutine. Request key C<uri> is required
and must contain at least module and subroutine name.

=item * uri => STR

Specify module and/or sub and/or arguments. See L<Sub::Spec::URI> for more
details. If invalid URI is found, server MUST return 400.

=item * args => HASH (default {})

To specify arguments. Must be a hashref, or the server MUST return 400.

=item * output_format => STR

To specify response format. Known formats are 'yaml', 'json', 'phps', 'pretty',
'simple', 'html'. A server can support more formats, but at least it MUST
support 'json'.

Server can pick default format as it deems necessary/convenient.

=item * log_level => INT|STR (default 0)

Am integer number between 0 (lowest, none) and 6 (highest, trace) or string
(either "none" [0], "fatal" [1], "error" [2], "warn" [3], "info" [4], "debug"
[5], "trace" [6]). Relevant only for 'call' command. When specified, a server
should return log messages (e.g. produced by L<Log::Any>) to the client in the
HTTP response.

=item * mark_log => BOOL (default 0)

If set to true, prepend each log message with "L" (and response with "R") in
each response chunk. Only useful/relevant when turning on log_level > 0, so
clients can parse/separate log message from response.

=back


=head1 SS SERVER

An SS server listens to HTTP requests, parses them into SS requests, and
executes the SS requests for clients.

=head2 Parsing SS request from HTTP request

Server at least MUST parse SS request keys from HTTP C<X-SS-Req-*> request
headers, e.g. C<X-SS-Req-Command> header for setting the C<command> request key.
In addition, the server MUST parse C<X-SS-Req-*-j-> for JSON-encoded value, e.g.

 X-SS-Req-Args-j-: {arg1:"val1",arg2:[1,2,3]}

should set C<args> request key to C<{arg1 => "val1", arg2 => [1, 2, 3]}>.

The server MUST also accept request body for C<args>. The server MUST accept at
least body of type C<application/json>. It can accept additional types if it
wants, e.g. C<text/yaml> or C<application/vnd.php.serialized>.

The server can also accept SS request keys or sub arguments using other means,
for example, Sub::Spec::HTTP::Server allows setting C<module> and C<sub> from
URI path, and arguments (as well as other SS request keys, using C<-ss-req-*>
syntax) from request variables. For example:

 http://HOST/api/MOD::SUBMOD/FUNC?a1=1&a2:j=[1,2]&-ss-req-command=spec

will result in the following SS request:

 {
  command => 'spec',
  uri     => 'pm://MOD::SUBMOD/FUNC',
  args    => {a1=>1, a2=>[1, 2]},
 }


=head1 SS CLIENT


=head1 FAQ

=head2 Why not directly use status code and message from enveloped result as HTTP response status code and message?

To be able to differentiate between errors from the HTTP service and from the
API functions.

Suppose you use an API service to manage some email accounts. You call an API
function to get information on a certain mail account, and you keep getting a
404 Not Found error. If the status code were mixed with that from the webserver,
how would you know that the error is from the webserver or from the API
function? In the first case, your email account might still exist but the
webserver/API service might be misconfigured or moved. In the second case, your
desired email might really be gone.


=head1 SEE ALSO

L<Rinci>

=cut
