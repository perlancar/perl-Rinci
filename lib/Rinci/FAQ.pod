package Rinci::FAQ; # just to make PodWeaver happy

# DATE
# VERSION

1;
# ABSTRACT: Metadata for your functions/methods

=head1 FAQ

=head2 Rinci::function

=over

=item * Why do you make enveloped result an arary instead of hash?

For example, a hash-based enveloped result can be something like:

 {status=>200, message=>"OK", result=>42, meta1=>..., meta2=>...}

This has the benefit of a single container, but I picked array because of the
brevity for simple cases (which are the majority), e.g.:

 [200]        # versus {status=>200}
 [200, "OK"]  # versus {status=>200, message=>"OK"}

When handling enveloped result, the array version is also shorter:

 if ($res->[0] == 200) { ... }
 # versus: if ($res->{status} == 200) { ... }

 print "Error $res->[0] - $res->[1]";
 # versus: print "Error $res->{status} - $res->{message}";

The hash version is more obvious for first-time reader, but after just some
amount of time, C<< $res->[0] >>, C<< $res->[1] >> will become obvious if you
use it consistently.

As a bonus, arrays are faster and more space-efficient than hashes.

=item * How do you indicate transient/temporary vs permanent errors?

Some protocols, like SMTP or POP, defines 4xx codes as temporary errors and 5xx
as permanent ones. This gives clue to clients whether to retry or not. HTTP,
which Rinci is modelled after, does not provide such distinction to its status
codes. However, Rinci defines a C<perm_err> result metadata that can be used for
such purpose, e.g.:

 [500, "Can't submit mail, we are being blocked by RBL", undef,
  {perm_err=>0}]

 [500, "Can't submit mail, destination address does not exist", undef,
  {perm_err=>1}]

=item * How to handle binary data?

To accept binary data, you can set one or more arguments as having the schema
type C<buf> (instead of C<str>):

 args => {
     data => { schema => 'buf*', req=>1 },
 }

To return binary data, you can set result's schema type to C<buf>, e.g.:

 result => { schema => 'buf*' }

For handling binary data when writing Perl-based command-line applications, see
L<Perinci::CmdLine::Manual::Examples>.

=item * How to accept partial data?

First, set an argument property C<partial> to true to signify that this argument
accept partial value. You can then call with special arguments C<-arg_len>,
C<-arg_part_start>, C<-arg_part_len>. See L<Rinci::function> for more details.
L<Riap::HTTP> can also do this via HTTP Content-Range.

=item * How to accept streaming input?

Many program environments (like in Unix) have the concept of standard input.
Rinci provides a thin abstraction over this. You can set the argument property
C<stream> to true. This way, in most implementation like in Perl, your function
will receive the argument value as filehandle which it can then read from. See
C<partial> property in C<args> function metadata property in L<Rinci::function>
for an example.

Your function can also read from standard input directly, but this means you
cannot use conveniences like the C<cmdline_src>, where the command-line
framework can supply an argument value for you from various sources including
standard input and/or files.

=item * How to produce streaming output?

Many program environments (like in Unix) have the concept of standard output. To
produce output stream, you can set result metadata property C<stream> to true.

Your function can also read from standard input directly, but this means you
cannot use conveniences like the C<cmdline_src>, where the command-line
framework can supply an argument value for you from various sources including
standard input and/or files.

=back
